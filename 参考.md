# 对接多个第三方API时，可使用到那几种设计模式？

    1. 策略模式
    首先，根据自有项目数据结构和应用场景，定义数据获取的接口（每个场景对于一个接口，可能会有多个接口），从而将接口定义和具体实现分割。
    
    2. 模板方法
    对于不同的实现方式（SDK、URL、Restful）定义主流程，比如Restful主流程包括：
    a. 输入参数验证
    b. 输入参数到restful参数转化（将接口输入参数，转化给restful参数）
    c. restful接口调用
    d. restful返回结果解析（成功、失败）
    e. restful返回结果转化（将结果转化为自有数据结构）
    
    3. 整合（接口定义来自1，实现通用部分来自2，差异部分来自3）
    根据具体实现继承自2创建的模板类，并实现1创建的业务接口，通过完成模板回调方法，完成整个业务。
    
    4. 其他
    如果有其他需要，比如统一日志、统一性能监控，可以使用proxy模式


创建型模式：工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式

结构型模式：适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式

行为型模式：责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式


# 创建型模式
创建型模式，就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。
关注的是对象的创建，创建型模式将创建对象的过程进行了抽象，也可以理解为将创建对象的过程进行了封装，作为客户程序仅仅需要去使用对象，而不再关系创建对象过程中的逻辑。
原始社会自给自足（没有工厂），农耕社会小作坊（简单工厂，民间酒坊），工业革命流水线（工厂方法，自产自销），现代产业链代工厂（抽象工厂，富士康）

## 简单工厂
工厂设置比较简单,由传入的参数控制生产的产品

## 工厂模式
简单的抽象工厂+简单的抽象产品 (工厂的基本模式,函数) => 具体工厂+具体产品,调用方只要用具体工厂名就可以按部就班的调用具体实现

## 抽象工厂
抽象工厂集合 多个(简单的抽象工厂+多个简单的抽象产品 (工厂的基本模式,函数)) => 多个具体实现(具体工厂+具体产品) 

## 创建者模式
将复杂任务分解成抽象的建造过程函数集合+抽象的指挥创建过程 => 具体的创建过程+具体的指挥函数 =>具体产品

## 原型模式
将复制一个已经创建好的对象,在原对象的副本基础上可以自动定义或扩展这个对象的属性

# 结构型模式
结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。
结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。

## 外观模式
定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。

## 适配器模式
创建一个是适配器,被适配的对象实现满足适配器调用的函数,适配器中调用此函数,使用者将对象放入适配器中,按是适配器的使用方式使用即可,方便使用者

## 代理模式
根据代理的创建时期，代理模式分为静态代理和动态代理。
    静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
    动态：在程序运行时，运用反射机制动态创建而成

## 装饰器模式
在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式
装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用

## 桥接模式
桥接模式分离抽象部分和实现部分。使得两部分独立扩展。 类似于策略模式，区别在于策略模式封装一系列算法使得算法可以互相替换。


# 行为模式
行为型模式涉及到算法和对象间职责的分配，行为模式描述了对象和类的模式，以及它们之间的通信模式，行为模式刻划了在程序运行时难以跟踪的复杂的控制流可分为行为类模式和行为对象模式。
1. 行为类模式使用继承机制在类间分派行为。
2. 行为对象模式使用对象聚合来分配行为。
一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任何一个对象都无法单独完成的任务。

## 观察者模式
观察者模式用于触发联动。一个对象的改变会触发其它观察者的相关动作，而此对象无需关心连动对象的具体实现。
多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式
实现上就是在对象的属性中加入需要被通知的其他对象,当自己变更的时候,遍历地去通知他们

## 模板模式
定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤
它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。

## 策略模式
该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。

## 状态模式
当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，
这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。
[l例子](https://refactoringguru.cn/design-patterns/state/go/example)

# 三者之间的区别和联系
    创建型模式提供生存环境，结构型模式提供生存理由，行为型模式提供如何生存。
    
    创建型模式为其他两种模式使用提供了环境。
    结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门。
    行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。

# 设计原则

    开闭原则： 对扩展开放，对修改关闭
    里氏转换原则： 子类继承父类，单独完全可以运行
    依赖倒转原则： 引用一个对象，如果这个对象有底层类型，直接引用底层类型
    接口隔离原则： 每一个接口应该是一种角色
    合成/聚合复用原则： 新的对象应使用一些已有的对象，使之成为新对象的一部分
    迪米特原则： 一个对象应对其他对象有尽可能少的了解

![图一](https://pic3.zhimg.com/v2-1acb8bad5b376dcd35bf71f9d65f1fb6_b.jpg)
# 常用的模式

- 工厂模式
- 单例模式
- 装饰器模式
- 策略模式
- 代理模式
- 观察者模式

# Golang不提供继承机制，需要使用匿名组合模拟实现继承
# 参考资料

- https://refactoringguru.cn/design-patterns/catalog
- https://refactoringguru.cn/design-patterns/go

